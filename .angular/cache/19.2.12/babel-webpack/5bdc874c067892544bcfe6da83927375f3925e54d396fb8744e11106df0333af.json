{"ast":null,"code":"/**\r\n * @license Angular v19.2.11\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError as _RuntimeError, ɵgetOutputDestroyRef as _getOutputDestroyRef, Injector, effect, untracked, ɵmicrotaskEffect as _microtaskEffect, assertNotInReactiveContext, signal, computed, PendingTasks, resource } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\r\n * Operator which completes the Observable when the calling context (component, directive, service,\r\n * etc) is destroyed.\r\n *\r\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\r\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\r\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\r\n *\r\n * @publicApi\r\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\r\n * Implementation of `OutputRef` that emits values from\r\n * an RxJS observable source.\r\n *\r\n * @internal\r\n */\nclass OutputFromObservableRef {\n  source;\n  destroyed = false;\n  destroyRef = inject(DestroyRef);\n  constructor(source) {\n    this.source = source;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new _RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\r\n * Declares an Angular output that is using an RxJS observable as a source\r\n * for events dispatched to parent subscribers.\r\n *\r\n * The behavior for an observable as source is defined as followed:\r\n *    1. New values are forwarded to the Angular output (next notifications).\r\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\r\n *       For example by using `catchError`.\r\n *    3. Completion notifications stop the output from emitting new values.\r\n *\r\n * @usageNotes\r\n * Initialize an output in your directive by declaring a\r\n * class field and initializing it with the `outputFromObservable()` function.\r\n *\r\n * ```ts\r\n * @Directive({..})\r\n * export class MyDir {\r\n *   nameChange$ = <some-observable>;\r\n *   nameChange = outputFromObservable(this.nameChange$);\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\r\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\r\n * to an observable.\r\n *\r\n * You can subscribe to the output via `Observable.subscribe` then.\r\n *\r\n * @publicApi\r\n */\nfunction outputToObservable(ref) {\n  const destroyRef = _getOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\r\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\r\n *\r\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\r\n *\r\n * `toObservable` must be called in an injection context unless an injector is provided via options.\r\n *\r\n * @developerPreview\r\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\nfunction toObservableMicrotask(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = _microtaskEffect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\r\n * Get the current value of an `Observable` as a reactive `Signal`.\r\n *\r\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\r\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\r\n * have the most recent value emitted by the subscription, and will throw an error if the\r\n * `Observable` errors.\r\n *\r\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\r\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\r\n * does not include an `undefined` type.\r\n *\r\n * By default, the subscription will be automatically cleaned up when the current [injection\r\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\r\n * called during the construction of a component, the subscription will be cleaned up when the\r\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\r\n * passed instead.\r\n *\r\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\r\n * option can be specified instead, which disables the automatic subscription teardown. No injection\r\n * context is needed in this configuration as well.\r\n *\r\n * @developerPreview\r\n */\nfunction toSignal(source, options) {\n  typeof ngDevMode !== 'undefined' && ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\r\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\r\n *\r\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\r\n *\r\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\r\n *\r\n * @experimental\r\n */\nfunction pendingUntilEvent(injector) {\n  if (injector === undefined) {\n    assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n  return sourceObservable => {\n    return new Observable(originalSubscriber => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n        removeTask();\n        cleanedUp = true;\n      }\n      const innerSubscription = sourceObservable.subscribe({\n        next: v => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: e => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        }\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\nfunction rxResource(opts) {\n  opts?.injector || assertInInjectionContext(rxResource);\n  return resource({\n    ...opts,\n    loader: undefined,\n    stream: params => {\n      let sub;\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n      // Start off stream as undefined.\n      const stream = signal({\n        value: undefined\n      });\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      function send(value) {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n      sub = opts.loader(params).subscribe({\n        next: value => send({\n          value\n        }),\n        error: error => send({\n          error\n        }),\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new Error('Resource completed before producing a value')\n            });\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }\n  });\n}\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal, toObservableMicrotask as ɵtoObservableMicrotask };","map":{"version":3,"names":["assertInInjectionContext","inject","DestroyRef","ɵRuntimeError","_RuntimeError","ɵgetOutputDestroyRef","_getOutputDestroyRef","Injector","effect","untracked","ɵmicrotaskEffect","_microtaskEffect","assertNotInReactiveContext","signal","computed","PendingTasks","resource","Observable","ReplaySubject","takeUntil","takeUntilDestroyed","destroyRef","destroyed$","observer","unregisterFn","onDestroy","next","bind","source","pipe","OutputFromObservableRef","destroyed","constructor","subscribe","callbackFn","ngDevMode","subscription","value","unsubscribe","outputFromObservable","observable","opts","outputToObservable","ref","complete","v","toObservable","options","injector","subject","watcher","err","error","manualCleanup","get","destroy","asObservable","toObservableMicrotask","toSignal","requiresCleanup","cleanupRef","equal","makeToSignalEqual","state","requireSync","kind","initialValue","sub","set","rejectErrors","current","userEquality","Object","is","a","b","pendingUntilEvent","undefined","taskService","sourceObservable","originalSubscriber","removeTask","add","cleanedUp","cleanupTask","innerSubscription","e","rxResource","loader","stream","params","onAbort","abortSignal","addEventListener","resolve","promise","Promise","r","send","Error","removeEventListener","ɵtoObservableMicrotask"],"sources":["C:/Users/rambo/OneDrive/Desktop/cudillo-frontend/frontend-cudillo/node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["/**\r\n * @license Angular v19.2.11\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError as _RuntimeError, ɵgetOutputDestroyRef as _getOutputDestroyRef, Injector, effect, untracked, ɵmicrotaskEffect as _microtaskEffect, assertNotInReactiveContext, signal, computed, PendingTasks, resource } from '@angular/core';\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\n\r\n/**\r\n * Operator which completes the Observable when the calling context (component, directive, service,\r\n * etc) is destroyed.\r\n *\r\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\r\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\r\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\r\n *\r\n * @publicApi\r\n */\r\nfunction takeUntilDestroyed(destroyRef) {\r\n    if (!destroyRef) {\r\n        assertInInjectionContext(takeUntilDestroyed);\r\n        destroyRef = inject(DestroyRef);\r\n    }\r\n    const destroyed$ = new Observable((observer) => {\r\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\r\n        return unregisterFn;\r\n    });\r\n    return (source) => {\r\n        return source.pipe(takeUntil(destroyed$));\r\n    };\r\n}\r\n\r\n/**\r\n * Implementation of `OutputRef` that emits values from\r\n * an RxJS observable source.\r\n *\r\n * @internal\r\n */\r\nclass OutputFromObservableRef {\r\n    source;\r\n    destroyed = false;\r\n    destroyRef = inject(DestroyRef);\r\n    constructor(source) {\r\n        this.source = source;\r\n        this.destroyRef.onDestroy(() => {\r\n            this.destroyed = true;\r\n        });\r\n    }\r\n    subscribe(callbackFn) {\r\n        if (this.destroyed) {\r\n            throw new _RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected subscription to destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.');\r\n        }\r\n        // Stop yielding more values when the directive/component is already destroyed.\r\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\r\n            next: (value) => callbackFn(value),\r\n        });\r\n        return {\r\n            unsubscribe: () => subscription.unsubscribe(),\r\n        };\r\n    }\r\n}\r\n/**\r\n * Declares an Angular output that is using an RxJS observable as a source\r\n * for events dispatched to parent subscribers.\r\n *\r\n * The behavior for an observable as source is defined as followed:\r\n *    1. New values are forwarded to the Angular output (next notifications).\r\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\r\n *       For example by using `catchError`.\r\n *    3. Completion notifications stop the output from emitting new values.\r\n *\r\n * @usageNotes\r\n * Initialize an output in your directive by declaring a\r\n * class field and initializing it with the `outputFromObservable()` function.\r\n *\r\n * ```ts\r\n * @Directive({..})\r\n * export class MyDir {\r\n *   nameChange$ = <some-observable>;\r\n *   nameChange = outputFromObservable(this.nameChange$);\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nfunction outputFromObservable(observable, opts) {\r\n    ngDevMode && assertInInjectionContext(outputFromObservable);\r\n    return new OutputFromObservableRef(observable);\r\n}\r\n\r\n/**\r\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\r\n * to an observable.\r\n *\r\n * You can subscribe to the output via `Observable.subscribe` then.\r\n *\r\n * @publicApi\r\n */\r\nfunction outputToObservable(ref) {\r\n    const destroyRef = _getOutputDestroyRef(ref);\r\n    return new Observable((observer) => {\r\n        // Complete the observable upon directive/component destroy.\r\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\r\n        // of an injection context.\r\n        destroyRef?.onDestroy(() => observer.complete());\r\n        const subscription = ref.subscribe((v) => observer.next(v));\r\n        return () => subscription.unsubscribe();\r\n    });\r\n}\r\n\r\n/**\r\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\r\n *\r\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\r\n *\r\n * `toObservable` must be called in an injection context unless an injector is provided via options.\r\n *\r\n * @developerPreview\r\n */\r\nfunction toObservable(source, options) {\r\n    !options?.injector && assertInInjectionContext(toObservable);\r\n    const injector = options?.injector ?? inject(Injector);\r\n    const subject = new ReplaySubject(1);\r\n    const watcher = effect(() => {\r\n        let value;\r\n        try {\r\n            value = source();\r\n        }\r\n        catch (err) {\r\n            untracked(() => subject.error(err));\r\n            return;\r\n        }\r\n        untracked(() => subject.next(value));\r\n    }, { injector, manualCleanup: true });\r\n    injector.get(DestroyRef).onDestroy(() => {\r\n        watcher.destroy();\r\n        subject.complete();\r\n    });\r\n    return subject.asObservable();\r\n}\r\nfunction toObservableMicrotask(source, options) {\r\n    !options?.injector && assertInInjectionContext(toObservable);\r\n    const injector = options?.injector ?? inject(Injector);\r\n    const subject = new ReplaySubject(1);\r\n    const watcher = _microtaskEffect(() => {\r\n        let value;\r\n        try {\r\n            value = source();\r\n        }\r\n        catch (err) {\r\n            untracked(() => subject.error(err));\r\n            return;\r\n        }\r\n        untracked(() => subject.next(value));\r\n    }, { injector, manualCleanup: true });\r\n    injector.get(DestroyRef).onDestroy(() => {\r\n        watcher.destroy();\r\n        subject.complete();\r\n    });\r\n    return subject.asObservable();\r\n}\r\n\r\n/**\r\n * Get the current value of an `Observable` as a reactive `Signal`.\r\n *\r\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\r\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\r\n * have the most recent value emitted by the subscription, and will throw an error if the\r\n * `Observable` errors.\r\n *\r\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\r\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\r\n * does not include an `undefined` type.\r\n *\r\n * By default, the subscription will be automatically cleaned up when the current [injection\r\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\r\n * called during the construction of a component, the subscription will be cleaned up when the\r\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\r\n * passed instead.\r\n *\r\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\r\n * option can be specified instead, which disables the automatic subscription teardown. No injection\r\n * context is needed in this configuration as well.\r\n *\r\n * @developerPreview\r\n */\r\nfunction toSignal(source, options) {\r\n    typeof ngDevMode !== 'undefined' &&\r\n        ngDevMode &&\r\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\r\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\r\n    const requiresCleanup = !options?.manualCleanup;\r\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\r\n    const cleanupRef = requiresCleanup\r\n        ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\r\n        : null;\r\n    const equal = makeToSignalEqual(options?.equal);\r\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\r\n    // the same - the returned signal gives values of type `T`.\r\n    let state;\r\n    if (options?.requireSync) {\r\n        // Initially the signal is in a `NoValue` state.\r\n        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });\r\n    }\r\n    else {\r\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\r\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });\r\n    }\r\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\r\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\r\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\r\n    // consumer only needs to be notified when the `state` signal changes through the observable\r\n    // subscription. Additional context (related to async pipe):\r\n    // https://github.com/angular/angular/pull/50522.\r\n    const sub = source.subscribe({\r\n        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),\r\n        error: (error) => {\r\n            if (options?.rejectErrors) {\r\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\r\n                // the error to end up as an uncaught exception.\r\n                throw error;\r\n            }\r\n            state.set({ kind: 2 /* StateKind.Error */, error });\r\n        },\r\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\r\n        // \"complete\".\r\n    });\r\n    if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\r\n        throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n    }\r\n    // Unsubscribe when the current context is destroyed, if requested.\r\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\r\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\r\n    // to either values or errors.\r\n    return computed(() => {\r\n        const current = state();\r\n        switch (current.kind) {\r\n            case 1 /* StateKind.Value */:\r\n                return current.value;\r\n            case 2 /* StateKind.Error */:\r\n                throw current.error;\r\n            case 0 /* StateKind.NoValue */:\r\n                // This shouldn't really happen because the error is thrown on creation.\r\n                throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                    '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n        }\r\n    }, { equal: options?.equal });\r\n}\r\nfunction makeToSignalEqual(userEquality = Object.is) {\r\n    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\r\n}\r\n\r\n/**\r\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\r\n *\r\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\r\n *\r\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\r\n *\r\n * @experimental\r\n */\r\nfunction pendingUntilEvent(injector) {\r\n    if (injector === undefined) {\r\n        assertInInjectionContext(pendingUntilEvent);\r\n        injector = inject(Injector);\r\n    }\r\n    const taskService = injector.get(PendingTasks);\r\n    return (sourceObservable) => {\r\n        return new Observable((originalSubscriber) => {\r\n            // create a new task on subscription\r\n            const removeTask = taskService.add();\r\n            let cleanedUp = false;\r\n            function cleanupTask() {\r\n                if (cleanedUp) {\r\n                    return;\r\n                }\r\n                removeTask();\r\n                cleanedUp = true;\r\n            }\r\n            const innerSubscription = sourceObservable.subscribe({\r\n                next: (v) => {\r\n                    originalSubscriber.next(v);\r\n                    cleanupTask();\r\n                },\r\n                complete: () => {\r\n                    originalSubscriber.complete();\r\n                    cleanupTask();\r\n                },\r\n                error: (e) => {\r\n                    originalSubscriber.error(e);\r\n                    cleanupTask();\r\n                },\r\n            });\r\n            innerSubscription.add(() => {\r\n                originalSubscriber.unsubscribe();\r\n                cleanupTask();\r\n            });\r\n            return innerSubscription;\r\n        });\r\n    };\r\n}\r\n\r\nfunction rxResource(opts) {\r\n    opts?.injector || assertInInjectionContext(rxResource);\r\n    return resource({\r\n        ...opts,\r\n        loader: undefined,\r\n        stream: (params) => {\r\n            let sub;\r\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\r\n            // optimization).\r\n            const onAbort = () => sub.unsubscribe();\r\n            params.abortSignal.addEventListener('abort', onAbort);\r\n            // Start off stream as undefined.\r\n            const stream = signal({ value: undefined });\r\n            let resolve;\r\n            const promise = new Promise((r) => (resolve = r));\r\n            function send(value) {\r\n                stream.set(value);\r\n                resolve?.(stream);\r\n                resolve = undefined;\r\n            }\r\n            sub = opts.loader(params).subscribe({\r\n                next: (value) => send({ value }),\r\n                error: (error) => send({ error }),\r\n                complete: () => {\r\n                    if (resolve) {\r\n                        send({ error: new Error('Resource completed before producing a value') });\r\n                    }\r\n                    params.abortSignal.removeEventListener('abort', onAbort);\r\n                },\r\n            });\r\n            return promise;\r\n        },\r\n    });\r\n}\r\n\r\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal, toObservableMicrotask as ɵtoObservableMicrotask };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}